/**
 * WorkflowTemplateModal - Interactive guided workflow template
 */
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { X, ArrowRight, Loader2, CheckCircle, MessageSquare, FileText } from 'lucide-react';
import jsPDF from 'jspdf';

interface WorkflowTemplateModalProps {
  isOpen: boolean;
  onClose: () => void;
  template: any;
}

// Helper function to compile report from agent outputs
const compileReport = (outputs: Record<number, any>, guide: any, responses: Record<number, string>): string => {
  let report = `# ${guide.title}\n\n`;
  report += `${guide.description}\n\n`;
  report += `---\n\n`;
  
  Object.entries(outputs).forEach(([stepIndex, output]) => {
    const step = guide.steps[parseInt(stepIndex)];
    const userResponse = responses[parseInt(stepIndex)];
    
    report += `## ${step.agent} Agent\n\n`;
    if (userResponse) {
      report += `**Your Input:** ${userResponse}\n\n`;
    }
    report += `**Agent Analysis:**\n\n`;
    
    // Extract natural language response
    const result = output.result || output;
    const response = result.response || result.data;
    
    if (typeof response === 'string') {
      report += response.replace(/<think>[\s\S]*?<\/think>/g, '').trim() + '\n\n';
    } else if (response && typeof response === 'object') {
      if (response.refined_concept) report += response.refined_concept.replace(/<think>[\s\S]*?<\/think>/g, '').trim() + '\n\n';
      else if (response.analysis) report += response.analysis.replace(/<think>[\s\S]*?<\/think>/g, '').trim() + '\n\n';
      else if (response.summary) report += response.summary + '\n\n';
      else if (response.recommendations) {
        const recs = Array.isArray(response.recommendations) ? response.recommendations.join('\n\n') : response.recommendations;
        report += recs + '\n\n';
      } else {
        report += JSON.stringify(response, null, 2) + '\n\n';
      }
    }
    
    report += `---\n\n`;
  });
  
  report += `\n\n*Generated by ProdPlex Multi-Agent System*\n`;
  report += `*Date: ${new Date().toLocaleString()}*`;
  
  return report;
};

// Define template-specific prompts and guidance
const TEMPLATE_GUIDES: Record<string, any> = {
  'full_feature_planning': {
    title: 'Full Feature Planning',
    description: 'Complete end-to-end feature planning with all 9 agents',
    steps: [
      {
        agent: 'Strategy',
        question: 'What feature are you planning to build?',
        placeholder: 'E.g., AI-powered expense categorization for mobile banking',
        followUp: 'Who is your target market?',
        followUpPlaceholder: 'E.g., Mobile banking users aged 25-45'
      },
      {
        agent: 'Research',
        question: 'What market insights do you need?',
        placeholder: 'E.g., Competitive analysis, user pain points, market trends',
        auto: true,
        autoPrompt: (context: any) => `Research the market for ${context.feature} targeting ${context.market}`
      },
      {
        agent: 'Development',
        question: 'What technical requirements should we consider?',
        placeholder: 'E.g., Must integrate with existing systems, need real-time processing',
        auto: true,
        autoPrompt: (context: any) => `Create user stories and technical requirements for ${context.feature}`
      },
      {
        agent: 'Prototype',
        question: 'What UI/UX elements are important?',
        placeholder: 'E.g., Simple onboarding, intuitive dashboard, mobile-first design',
        auto: true,
        autoPrompt: (context: any) => `Generate mockup concepts for ${context.feature}`
      }
    ]
  },
  'research_and_strategy': {
    title: 'Research & Strategy',
    description: 'Market research and strategic analysis',
    steps: [
      {
        agent: 'Research',
        question: 'What do you want to research?',
        placeholder: 'E.g., Competitor features, market trends, user preferences'
      },
      {
        agent: 'Strategy',
        question: 'What are your strategic goals?',
        placeholder: 'E.g., Increase market share, differentiate from competitors',
        auto: true,
        autoPrompt: (context: any) => `Develop strategy based on research for ${context.research_goal}`
      }
    ]
  },
  'dev_planning': {
    title: 'Development Planning',
    description: 'User stories, technical specs, and prototyping',
    steps: [
      {
        agent: 'Development',
        question: 'What feature are you developing?',
        placeholder: 'E.g., User authentication system with OAuth'
      },
      {
        agent: 'Prototype',
        question: 'Describe the user flow',
        placeholder: 'E.g., Login → Dashboard → Settings',
        auto: true,
        autoPrompt: (context: any) => `Create wireframes for ${context.feature_name}`
      }
    ]
  },
  'launch_planning': {
    title: 'Launch Planning',
    description: 'Go-to-market strategy and automation',
    steps: [
      {
        agent: 'GTM',
        question: 'What are you launching?',
        placeholder: 'E.g., New mobile app feature'
      },
      {
        agent: 'Automation',
        question: 'What processes need automation?',
        placeholder: 'E.g., User onboarding, email campaigns, analytics tracking',
        auto: true,
        autoPrompt: (context: any) => `Recommend automation workflows for launching ${context.product}`
      }
    ]
  },
  'compliance_check': {
    title: 'Compliance Check',
    description: 'Regulatory compliance and risk assessment',
    steps: [
      {
        agent: 'Regulation',
        question: 'What feature needs compliance review?',
        placeholder: 'E.g., Payment processing system, user data collection'
      },
      {
        agent: 'Risk',
        question: 'What regulations apply?',
        placeholder: 'E.g., GDPR, PCI-DSS, HIPAA',
        auto: true,
        autoPrompt: (context: any) => `Assess risks and compliance for ${context.feature} under ${context.regulations || 'applicable regulations'}`
      }
    ]
  }
};

export const WorkflowTemplateModal: React.FC<WorkflowTemplateModalProps> = ({
  isOpen,
  onClose,
  template
}) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [responses, setResponses] = useState<Record<number, string>>({});
  const [agentOutputs, setAgentOutputs] = useState<Record<number, any>>({});
  const [loading, setLoading] = useState(false);
  const [context, setContext] = useState<Record<string, any>>({});
  const [isComplete, setIsComplete] = useState(false);
  const [compiledReport, setCompiledReport] = useState<string>('');

  const guide = TEMPLATE_GUIDES[template?.name] || TEMPLATE_GUIDES['full_feature_planning'];
  const currentStepData = guide.steps[currentStep];
  const isLastStep = currentStep === guide.steps.length - 1;

  const handleNext = async () => {
    const response = responses[currentStep];
    if (!response?.trim()) return;

    setLoading(true);

    // Build context for future prompts
    const newContext = { ...context };
    if (currentStep === 0) {
      newContext.feature = response;
    } else if (currentStep === 1 && currentStepData.followUp) {
      newContext.market = response;
    }
    setContext(newContext);

    // Call agent
    try {
      const agentName = currentStepData.agent.toLowerCase();
      const prompt = currentStepData.auto && currentStepData.autoPrompt
        ? currentStepData.autoPrompt(newContext)
        : response;

      const agentResponse = await fetch(`http://localhost:8000/api/v1/agents/${agentName}/execute`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          agent_name: agentName,
          task_type: 'chat',
          input_data: { message: prompt }
        })
      });

      const result = await agentResponse.json();
      
      const newOutputs = {
        ...agentOutputs,
        [currentStep]: result.result || result
      };
      setAgentOutputs(newOutputs);

      // Move to next step or finish
      if (!isLastStep) {
        setCurrentStep(currentStep + 1);
      } else {
        // Compile final report
        const report = compileReport(newOutputs, guide, responses);
        setCompiledReport(report);
        setIsComplete(true);
      }
    } catch (error) {
      console.error('Error calling agent:', error);
      alert('Failed to process. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleReset = () => {
    setCurrentStep(0);
    setResponses({});
    setAgentOutputs({});
    setContext({});
  };

  if (!isOpen) return null;

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4"
        onClick={onClose}
      >
        <motion.div
          initial={{ scale: 0.9, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.9, opacity: 0 }}
          className="bg-dark-lighter border border-dark-border rounded-xl max-w-3xl w-full max-h-[85vh] overflow-hidden flex flex-col"
          onClick={(e) => e.stopPropagation()}
        >
          {/* Header */}
          <div className="p-6 border-b border-dark-border">
            <div className="flex items-start justify-between mb-2">
              <div>
                <h2 className="text-2xl font-bold text-white mb-1">{guide.title}</h2>
                <p className="text-sm text-silver/70">{guide.description}</p>
              </div>
              <button
                onClick={onClose}
                className="text-silver/70 hover:text-white transition-colors"
              >
                <X className="w-6 h-6" />
              </button>
            </div>
            
            {/* Progress */}
            <div className="mt-4">
              <div className="flex items-center gap-2 mb-2">
                <span className="text-xs text-silver/50">
                  Step {currentStep + 1} of {guide.steps.length}
                </span>
                <span className="text-xs text-purple-400 font-semibold">
                  {currentStepData.agent} Agent
                </span>
              </div>
              <div className="w-full bg-dark-border h-1 rounded-full overflow-hidden">
                <motion.div
                  className="h-full bg-gradient-to-r from-purple-500 to-blue-500"
                  initial={{ width: 0 }}
                  animate={{ width: `${((currentStep + 1) / guide.steps.length) * 100}%` }}
                  transition={{ duration: 0.3 }}
                />
              </div>
            </div>
          </div>

          {/* Content */}
          <div className="flex-1 overflow-y-auto p-6 space-y-6">
            {isComplete ? (
              /* Completion View */
              <div className="space-y-4">
                <div className="bg-green-500/10 border border-green-500/30 rounded-lg p-4 flex items-start gap-3">
                  <CheckCircle className="w-6 h-6 text-green-400 mt-0.5 flex-shrink-0" />
                  <div>
                    <h3 className="font-semibold text-green-400 mb-1 text-lg">Workflow Complete!</h3>
                    <p className="text-sm text-silver/70">
                      All agents have completed their analysis. Your comprehensive report is ready.
                    </p>
                  </div>
                </div>

                {/* Compiled Report */}
                <div className="bg-dark-lighter border border-dark-border rounded-lg p-6">
                  <h3 className="text-lg font-semibold text-white mb-4">Compiled Report</h3>
                  <div className="prose prose-invert prose-sm max-w-none bg-dark rounded-lg p-4 max-h-96 overflow-y-auto">
                    <pre className="whitespace-pre-wrap font-sans text-silver/90 leading-relaxed">
                      {compiledReport}
                    </pre>
                  </div>
                </div>

                {/* Download Button */}
                <button
                  onClick={() => {
                    const doc = new jsPDF();
                    const filename = `${guide.title.replace(/\s+/g, '_')}_Report_${Date.now()}.pdf`;
                    
                    let yPosition = 20;
                    const pageWidth = doc.internal.pageSize.getWidth();
                    const margin = 20;
                    const maxWidth = pageWidth - (margin * 2);
                    
                    // Helper function
                    const addText = (text: string, fontSize: number = 10, isBold: boolean = false) => {
                      doc.setFontSize(fontSize);
                      if (isBold) doc.setFont('helvetica', 'bold');
                      else doc.setFont('helvetica', 'normal');
                      
                      const lines = doc.splitTextToSize(text, maxWidth);
                      lines.forEach((line: string) => {
                        if (yPosition > 280) {
                          doc.addPage();
                          yPosition = 20;
                        }
                        doc.text(line, margin, yPosition);
                        yPosition += fontSize * 0.5;
                      });
                      yPosition += 5;
                    };
                    
                    // Parse and add content
                    const lines = compiledReport.split('\n');
                    lines.forEach((line: string) => {
                      if (line.startsWith('# ')) {
                        addText(line.replace('# ', ''), 16, true);
                      } else if (line.startsWith('## ')) {
                        addText(line.replace('## ', ''), 14, true);
                      } else if (line.startsWith('**') && line.endsWith('**')) {
                        addText(line.replace(/\*\*/g, ''), 11, true);
                      } else if (line.trim() === '---') {
                        if (yPosition < 270) {
                          doc.setDrawColor(200, 200, 200);
                          doc.line(margin, yPosition, pageWidth - margin, yPosition);
                          yPosition += 10;
                        }
                      } else if (line.trim()) {
                        addText(line, 10);
                      }
                    });
                    
                    doc.save(filename);
                  }}
                  className="btn btn-primary w-full flex items-center justify-center gap-2"
                >
                  <FileText className="w-4 h-4" />
                  Download Report as PDF
                </button>
              </div>
            ) : (
              /* Current Question */
              <div>
                <div className="flex items-start gap-3 mb-4">
                  <MessageSquare className="w-5 h-5 text-purple-400 mt-1 flex-shrink-0" />
                  <div>
                    <h3 className="text-lg font-semibold text-white mb-2">
                      {currentStepData.question}
                    </h3>
                    {currentStepData.followUp && !responses[currentStep] && (
                      <p className="text-sm text-silver/60 italic">
                        Follow-up: {currentStepData.followUp}
                      </p>
                    )}
                  </div>
                </div>
                
                <textarea
                  value={responses[currentStep] || ''}
                  onChange={(e) => setResponses({ ...responses, [currentStep]: e.target.value })}
                  placeholder={currentStepData.placeholder}
                  className="input w-full h-32 resize-none"
                  disabled={loading}
                />
              </div>
            )}

            {/* Previous Outputs */}
            {!isComplete && Object.keys(agentOutputs).length > 0 && (
              <div className="border-t border-dark-border pt-6">
                <h4 className="text-sm font-semibold text-white mb-4 flex items-center gap-2">
                  <CheckCircle className="w-4 h-4 text-green-400" />
                  Completed Steps
                </h4>
                <div className="space-y-3">
                  {Object.entries(agentOutputs).map(([stepIndex, output]: [string, any]) => {
                    const step = guide.steps[parseInt(stepIndex)];
                    return (
                      <div key={stepIndex} className="bg-dark rounded-lg p-4 border border-dark-border">
                        <div className="flex items-center gap-2 mb-3">
                          <CheckCircle className="w-4 h-4 text-green-400" />
                          <span className="text-sm font-semibold text-white">{step.agent} Agent</span>
                        </div>
                        <div className="text-sm text-silver/90 leading-relaxed max-h-48 overflow-y-auto">
                          {(() => {
                            // Extract natural language response
                            const result = output.result || output;
                            const response = result.response || result.data;
                            
                            if (typeof response === 'string') {
                              // Remove <think> tags
                              return response.replace(/<think>[\s\S]*?<\/think>/g, '').trim();
                            } else if (response && typeof response === 'object') {
                              // Extract meaningful fields
                              if (response.refined_concept) return response.refined_concept.replace(/<think>[\s\S]*?<\/think>/g, '').trim();
                              if (response.analysis) return response.analysis.replace(/<think>[\s\S]*?<\/think>/g, '').trim();
                              if (response.summary) return response.summary;
                              if (response.recommendations) return Array.isArray(response.recommendations) 
                                ? response.recommendations.join('\n\n') 
                                : response.recommendations;
                              
                              // Show first few key fields
                              return Object.entries(response)
                                .slice(0, 3)
                                .map(([key, value]) => `${key}: ${String(value).substring(0, 100)}`)
                                .join('\n');
                            }
                            
                            return 'Completed successfully';
                          })()}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            )}
          </div>

          {/* Footer */}
          <div className="p-6 border-t border-dark-border flex items-center justify-between">
            {isComplete ? (
              <button
                onClick={() => {
                  handleReset();
                  setIsComplete(false);
                  setCompiledReport('');
                }}
                className="btn bg-dark-border hover:bg-dark text-white"
              >
                Start New Workflow
              </button>
            ) : (
              <button
                onClick={handleReset}
                className="text-sm text-silver/70 hover:text-white transition-colors"
              >
                Start Over
              </button>
            )}
            <div className="flex gap-3">
              <button
                onClick={onClose}
                className="btn bg-dark-border hover:bg-dark text-white"
              >
                {isComplete ? 'Close' : 'Cancel'}
              </button>
              {!isComplete && (
                <button
                  onClick={handleNext}
                  disabled={!responses[currentStep]?.trim() || loading}
                  className="btn btn-primary disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                >
                  {loading ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin" />
                      Processing...
                    </>
                  ) : isLastStep ? (
                    <>
                      <CheckCircle className="w-4 h-4" />
                      Complete
                    </>
                  ) : (
                    <>
                      Next Step
                      <ArrowRight className="w-4 h-4" />
                    </>
                  )}
                </button>
              )}
            </div>
          </div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
};

export default WorkflowTemplateModal;

